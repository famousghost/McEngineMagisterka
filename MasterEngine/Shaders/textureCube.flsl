#version 330 core

uniform sampler2D texture1;
uniform sampler2D normalTexture;

in vec3 normCoords;
in vec3 wPos;
in vec2 texturesCoords;

out vec4 fragColor;

uniform vec3 cameraPos;
uniform vec3 lightPosition;
float shinness = 128.0;

struct Material
{
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	vec3 objectColor;
};

uniform Material material;

vec3 calculateAmbientLight()
{
	vec3 ambientLight = material.ambient * material.objectColor;
	return ambientLight;
}

vec3 calculateDiffuseLight(vec3 lightPos, vec3 normalCor)
{
	float diffueColor = max(dot(lightPos, normalCor), 0.0);
	vec3 diffuseLight = material.diffuse * diffueColor * material.objectColor;
	
	return diffuseLight;
}

vec3 calculateSpecularLight(vec3 lightPos, vec3 normalCor)
{
	vec3 lightReflected = reflect(-lightPos, normalCor);
	vec3 cameraWorldPostion = normalize(cameraPos - wPos);
	float specularColor = pow(max(dot(cameraWorldPostion, lightReflected), 0.0), shinness);
	vec3 specularLight = material.specular * specularColor * material.objectColor;
	
	return specularLight;
}

void main()
{
	vec3 normalCor = texture(normalTexture, texturesCoords).rgb;
	vec3 lightPos = normalize(lightPosition - wPos);
	vec3 ambientLight = calculateAmbientLight();
	vec3 diffuseLight;
	vec3 specularLight;
	if (normalCor != vec3(0.0, 0.0, 0.0))
	{
		normalCor = normalize(normalCor * 2.0 - 1.0);
		diffuseLight = calculateDiffuseLight(lightPos, normalCor) + calculateDiffuseLight(lightPos, normCoords);
		specularLight = calculateSpecularLight(lightPos, normalCor) + calculateDiffuseLight(lightPos, normCoords);
	}
	else
	{
		diffuseLight = calculateDiffuseLight(lightPos, normCoords);
		specularLight = calculateDiffuseLight(lightPos, normCoords);
	}
	vec4 textureColor = texture(texture1, texturesCoords);
	fragColor = textureColor * vec4(ambientLight + diffuseLight + specularLight, 1.0);
}